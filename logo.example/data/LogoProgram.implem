use logo.example.service.Display;

class LogoProgram {

	@main
	def Turtle eval() {
		/*for(i in [0..5]){
		 i.log();
		}
		for(i in [10..5]){
		 i.log();
		}*/
		Turtle turtle :=  self.createTurtle();
	
		for(it in self.instructions){
			it.eval(turtle);
		}
		result := turtle;
		turtle.show();
	}
	
	def Turtle createTurtle() {
		Turtle turtle := vmlogo::Turtle.create();
		turtle.position := vmlogo::Point.create();
		turtle.position.x := 0.0;
		turtle.position.y := 0.0;
		turtle.callStack := vmlogo::CallStack.create();
		turtle.callStack.frames.add(vmlogo::StackFrame.create());
		result := turtle;
	}
}


class PenDown {
	def double eval(Turtle turtle) {
		turtle.penUp := false;
//		('Log from PenDown : ' + turtle.penUp).log() ;
	}
}

class PenUp {
	def double eval(Turtle turtle) {
		turtle.penUp := true;
//		('Log from PenUp : ' + turtle.penUp).log() ;
	}
}

class Repeat {
	def double eval(Turtle turtle) {
//		'Log from Repeat'.log() ;
		
		int time := self.condition.eval(turtle);
		while( time > 0.0 ){
			self.block.eval(turtle);
			time := time - 1.0;
		}
	}
}

class While {
	def double eval(Turtle turtle) {
		while(self.condition.eval(turtle) > 0){
			self.block.eval(turtle);
		}
		result := 0;
	}
}

class If {
	def double eval(Turtle turtle) {
		if (self.condition.eval(turtle) != 0) {
			result := self.thenPart.eval(turtle);
		}
		else{
			result := self.elsePart.eval(turtle);
		}
	}
}

class Constant {
	def double eval(Turtle turtle) {
		//('Log from Constant '+self.value).log();
		result := self.value;
	}
}

class Block {
	def double eval(Turtle turtle) {
//		'Log from Block'.log();
		for(inst in self.instructions){
			inst.eval(turtle);
		}
	}
}

class Clear {
	def double eval(CTurtle turtle) {
	}
}

class Forward {
	def double eval(Turtle turtle) {
		double move := self.steps.eval(turtle);
		turtle.forward(move);
//		('Log from Forward : ' + move).log();
	}
}

class Back {
	def double eval(Turtle turtle) {
		double move := self.steps.eval(turtle);
		turtle.forward(-move);
//		('Log from Back : ' + move).log();
	}
}

class Left {
	def double eval(Turtle turtle) {
		double angle := self.angle.eval(turtle);
		turtle.rotate(angle);
//		('Log from Left : ' + turtle.heading).log();
	}
}

class Right {
	def double eval(Turtle turtle) {
		double angle := self.angle.eval(turtle);
		turtle.rotate(-angle);
//		('Log from Right : ' + turtle.heading).log();
	}
}

class Plus {
	def double eval(Turtle turtle) {
		result := self.lhs.eval(turtle) + self.rhs.eval(turtle);
	}
}

class Minus {
	def double eval(Turtle turtle) {
		result := self.lhs.eval(turtle) - self.rhs.eval(turtle);
		('Minus ' + result).log;
	}
}

class Mult {
	def double eval(Turtle turtle) {
//	self.lhs.eval(turtle).log();
//	self.rhs.eval(turtle).log();
		result := self.lhs.eval(turtle) * self.rhs.eval(turtle);
	}
}

class Div {
	def double eval(Turtle turtle) {
		('Div ' + self.lhs).log;
		if(self.rhs.eval(turtle) != 0){
			result := self.lhs.eval(turtle) / self.rhs.eval(turtle);
		}
		else{
			result := 0;
		}
	}
}

class Equals {
	def double eval(Turtle turtle) {
		if(self.lhs.eval(turtle) = self.rhs.eval(turtle)){
			result := 1;
		}
		else{
			result := 0;
		}
	}
}

class Lower {
	def double eval(Turtle turtle) {
		if(self.lhs.eval(turtle) < self.rhs.eval(turtle)){
			result := 1;
		}
		else{
			result := 0;
		}
	}
}

class Greater {
	def double eval(Turtle turtle) {
		if(self.lhs.eval(turtle) > self.rhs.eval(turtle)){
			result := 1;
		}
		else{
			result := 0;
		}
	}
}

class Cos {
	def double eval(Turtle turtle) {
//		self.expression.eval(turtle).log();
		result := self.expression.eval(turtle).cosinus();
	}
}

class Sin {
	def double eval(Turtle turtle) {
		result := self.expression.sinus();
	}
}

class Tan {
	def double eval(Turtle turtle) {
		result := self.expression.tan();
	}
}

class ProcCall {
	def double eval(Turtle turtle) {
		('Calling '+self.declaration.name).log();
//(turtle.heading +' '+turtle.position.x+' '+ turtle.position.y).log();
	
		StackFrame newFrame := vmlogo::StackFrame.create();
		int i := 1;
		for (exp in self.actualArgs){
			Variable newVar := vmlogo::Variable.create();
			newVar.name := self.declaration.args->at(i).name;
			newVar.value := exp.eval(turtle);
			newFrame.variables.add(newVar);
			i := i+1;
//			(newVar.value).log();
		}
		turtle.callStack.frames.add(newFrame);
		
		result := 0;
		for(instr in self.declaration.instructions){
			result := instr.eval(turtle);
		}
		
		turtle.callStack.frames.remove(newFrame);
	}
}

class ParameterCall {
	def double eval(Turtle turtle){
		for(frame in turtle.callStack.frames){
			for(var in frame.variables){
				if(var.name = self.parameter.name){
					result := var.value;
//					(var.name + ' ' + var.value).log();
				}
			}
		}
	}
}
//--------------Context----------------------

class Turtle {

	int originalSize := 0.0;
	int anotherAttrib := 0.0;
	
	def void move(double dx, double dy) {
//		'debug move'.log();
		Point newPos := vmlogo::Point.create();
		newPos.x := self.position.x + dx;
		newPos.y := self.position.y  + dy;
		if(self.penUp) {
//			('Turtle move to '+ newPos.x +':'+newPos.y).log();
		}
		else {
//			('Turtle trace '+ self.position.x +':'+self.position.y +' to '+ newPos.x +':'+newPos.y +' head '+ self.heading).log();
			Segment newSegment := vmlogo::Segment.create();
			newSegment.begin := self.position;
			newSegment.end := newPos;
			self.drawings.add(newSegment);
		}
		Point newPosCopy := vmlogo::Point.create();
		newPosCopy.x := newPos.x;
		newPosCopy.y := newPos.y;
		self.position := newPosCopy;
	}
	
	def void forward(double steps) {
		self.move(steps*(self.heading.cosinus()), steps*(self.heading.sinus()));
	}
	
	def void rotate(double angle) {
		double newAngle := self.heading + angle;
		if(newAngle > 360.0){
				newAngle := newAngle - 360.0;
				self.heading := newAngle;
		}
		else{
			if(newAngle < 0.0){
				newAngle := 360.0 + newAngle;
				self.heading := newAngle;
			}
			else{
				self.heading := newAngle;
			}
		}
	}
}
